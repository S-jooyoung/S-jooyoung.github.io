{"componentChunkName":"component---src-templates-blog-template-js","path":"/what-twopointer-study/","result":{"data":{"cur":{"id":"8440081c-f9cc-5d0d-bf9f-3868dcc3414b","html":"<blockquote>\n<p>코딩 테스트 심심치 않게 나오는 <code class=\"language-text\">투 포인터 알고리즘</code>과 <code class=\"language-text\">슬라이딩 윈도우</code>에 대한 개념과 원리를 파악하고자 포스팅했습니다. 🧑🏻‍💻</p>\n</blockquote>\n<h2 id=\"투-포인터-알고리즘이란\" style=\"position:relative;\"><a href=\"#%ED%88%AC-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80\" aria-label=\"투 포인터 알고리즘이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>투 포인터 알고리즘이란?🧐</h2>\n<p><code class=\"language-text\">투 포인터 알고리즘</code>이란 이름 그대로 두 가지 포인터를 사용하여 문자열이나 배열에서 원하는 값을 찾는 방식이다. 대표적인 문제로는 <code class=\"language-text\">연속 부분 수열</code> 문제가 있다.</p>\n<h2 id=\"투-포인터-알고리즘-사용이유-\" style=\"position:relative;\"><a href=\"#%ED%88%AC-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%82%AC%EC%9A%A9%EC%9D%B4%EC%9C%A0-\" aria-label=\"투 포인터 알고리즘 사용이유  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>투 포인터 알고리즘 사용이유 💡</h2>\n<p>투 포인터 알고리즘 없이 무작정 탐색(반복문)을 사용하면 보통 이중 포문을 사용하면서 문제를 풀게 되는데 시간 복잡도 <code class=\"language-text\">O(n2)</code>이 넘어가며 너무 많은 시간이 걸리는 경우가 많다. 투 포인터 알고리즘은 반복문이 한번 돌기 때문에 시간 복잡도<code class=\"language-text\">O(n)</code>으로 더 효율적이다.</p>\n<blockquote>\n<p>말로는 어떠한 방법인지 알기 힘들므로 밑에서 유명한 연습문제를 보며 설명해 보겠습니다.😁</p>\n</blockquote>\n<h2 id=\"투-포인터-알고리즘-예제-\" style=\"position:relative;\"><a href=\"#%ED%88%AC-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%98%88%EC%A0%9C-\" aria-label=\"투 포인터 알고리즘 예제  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>투 포인터 알고리즘 예제 📝</h2>\n<blockquote>\n<p>N 개의 수로 이루어진 수열이 주어집니다. 이 수열에서 연속 부분 수열의 합이 특정 숫자 M이 되는 경우가 몇 번 있는지 구하는 프로그램을 작성하세요. 만약 N=8, M=6이고 수열이 다음과 같다면 12131112 합이 6이 되는 연속 부분 수열은 {2, 1, 3}, {1, 3, 1, 1},{3, 1, 1, 1}로 총 3가지입니다.</p>\n</blockquote>\n<h3 id=\"입력설명-️\" style=\"position:relative;\"><a href=\"#%EC%9E%85%EB%A0%A5%EC%84%A4%EB%AA%85-%EF%B8%8F\" aria-label=\"입력설명 ️ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>입력설명 🕵🏻‍♂️</h3>\n<p>첫째 줄에 N(1≤N≤100,000), M(1≤M≤100,000,000)이 주어진다. 수열의 원소값은 1,000을 넘지 않는 자연수이다.</p>\n<h3 id=\"입력예제-️\" style=\"position:relative;\"><a href=\"#%EC%9E%85%EB%A0%A5%EC%98%88%EC%A0%9C-%EF%B8%8F\" aria-label=\"입력예제 ️ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>입력예제 ✒️</h3>\n<p>10 5\n1 2 3 4 2 5 3 1 1 2</p>\n<h3 id=\"해결방식-\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EA%B2%B0%EB%B0%A9%EC%8B%9D-\" aria-label=\"해결방식  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해결방식 🗝</h3>\n<ul>\n<li>두 개의 포인터 <code class=\"language-text\">lt, rt</code>를 각각 0으로 세팅한다.</li>\n<li>연속 부분 수열의 합을 저장할 <code class=\"language-text\">sum</code>을 0으로 선언한다.</li>\n<li><code class=\"language-text\">rt</code>위치가 증가하면서 <code class=\"language-text\">sum</code>에 <code class=\"language-text\">rt</code> 위치의 값을 더한다.</li>\n<li>만약 <code class=\"language-text\">sum</code>값이 원하는 합보다 클 경우에 <code class=\"language-text\">lt</code>위치의 값을 빼주면서 <code class=\"language-text\">lt</code>를 증가시킨다.</li>\n<li>만약 <code class=\"language-text\">sum</code>값과 원하는 합의 값이 같다면 <code class=\"language-text\">answer</code>를 1증가 시킨다.</li>\n</ul>\n<h3 id=\"동작방식-\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%9E%91%EB%B0%A9%EC%8B%9D-\" aria-label=\"동작방식  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동작방식 🐎</h3>\n<p><img src=\"https://velog.velcdn.com/cloudflare/jooyoung/0e84ce67-3e17-498f-b561-a204c3b4146c/1.png\" alt=\"\"></p>\n<p><img src=\"https://velog.velcdn.com/cloudflare/jooyoung/34b2d674-79d5-45ac-ae4e-d5d0c002df15/2.png\" alt=\"\"></p>\n<p><img src=\"https://velog.velcdn.com/cloudflare/jooyoung/66a9510c-760e-4d44-960f-326ce04c3c1c/3.png\" alt=\"\"></p>\n<p><img src=\"https://velog.velcdn.com/cloudflare/jooyoung/2289b08f-5bce-4420-bfee-a1772b830006/4.png\" alt=\"\"></p>\n<p><img src=\"https://velog.velcdn.com/cloudflare/jooyoung/f06a9c33-ad2f-42ac-aa06-0c2bdcbe2bc8/5.png\" alt=\"\"></p>\n<p>이런 식으로 <code class=\"language-text\">5</code>보다 작다면 <code class=\"language-text\">rt</code>를 증가시키고 크다면 <code class=\"language-text\">lt</code>를 증가시키면서 값을 구하다 보면 <code class=\"language-text\">5</code>일 때의 값이 나오게 된다. 그럴 때마다 <code class=\"language-text\">answer</code>의 값을 증가시켜주면서 반복문을 끝까지 돌면 된다.</p>\n<blockquote>\n<p><code class=\"language-text\">투 포인터 알고리즘</code>과 비슷한 <code class=\"language-text\">슬라이딩 윈도우(sliding window)</code>라는 알고리즘도 존재합니다. <code class=\"language-text\">투 포인터</code>와 어떤 차이점이 있는지 밑에서 확인해 보겠습니다.</p>\n</blockquote>\n<h2 id=\"슬라이딩-윈도우sliding-window란\" style=\"position:relative;\"><a href=\"#%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%94%A9-%EC%9C%88%EB%8F%84%EC%9A%B0sliding-window%EB%9E%80\" aria-label=\"슬라이딩 윈도우sliding window란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>슬라이딩 윈도우(sliding window)란?🤔</h2>\n<p>마치 창문을 한쪽으로 밀면서 문제를 푸는 것과 모양이 유사해서 붙여진 이름이다. 투 포인터처럼 구간을 훑으면서 지나간다는 공통점은 있으나 어느 순간에도 그 구간의 넓이가 동일하다는 차이점이 있다. 구간의 넓이가 주어졌을 때는 슬라이딩 윈도우로 문제를 풀면 되겠다.</p>\n<h2 id=\"슬라이딩-윈도우sliding-window-예제-\" style=\"position:relative;\"><a href=\"#%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%94%A9-%EC%9C%88%EB%8F%84%EC%9A%B0sliding-window-%EC%98%88%EC%A0%9C-\" aria-label=\"슬라이딩 윈도우sliding window 예제  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>슬라이딩 윈도우(sliding window) 예제 📝</h2>\n<blockquote>\n<p>현수의 아빠는 제과점을 운영합니다. 현수 아빠는 현수에게 N일 동안의 매출기록을 주고 연속 된 K일 동안의 최대 매출액이 얼마인지 구하라고 했습니다. 만약 N=10이고 10일 간의 매출기록이 아래와 같습니다. 이때 K=3이면 12 15 11 20 25 10 20 19 13 15 연속된 3일간의 최대 매출액은 11+20+25=56만원입니다. 여러분이 현수를 도와주세요.</p>\n</blockquote>\n<h3 id=\"입력설명-️-1\" style=\"position:relative;\"><a href=\"#%EC%9E%85%EB%A0%A5%EC%84%A4%EB%AA%85-%EF%B8%8F-1\" aria-label=\"입력설명 ️ 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>입력설명 🕵🏻‍♂️</h3>\n<p>첫 줄에 N(5&#x3C;=N&#x3C;=100,000)과 M(2&#x3C;=K&#x3C;=N)가 주어진다.\n두 번째 줄에 N개의 숫자열이 주어진다. 각 숫자는 500이하의 음이 아닌 정수이다.</p>\n<h3 id=\"입력예제-️-1\" style=\"position:relative;\"><a href=\"#%EC%9E%85%EB%A0%A5%EC%98%88%EC%A0%9C-%EF%B8%8F-1\" aria-label=\"입력예제 ️ 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>입력예제 ✒️</h3>\n<p>7 3\n-3 3 1 -3 2 4 7</p>\n<h3 id=\"최대매출-해결방식-\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EB%8C%80%EB%A7%A4%EC%B6%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EC%8B%9D-\" aria-label=\"최대매출 해결방식  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최대매출 해결방식 🗝</h3>\n<ul>\n<li>매출의 합을 저장할 <code class=\"language-text\">res</code>을 선언하고 첫 번째 인덱스 값부터 k까지의 값의 합을 <code class=\"language-text\">res</code>에 저장한다.</li>\n<li>K부터 N의 길이까지 증가시키면서 k의 인덱스 값을 더하고 k-k의 값을 빼준다.</li>\n<li>반복문이 한번 돌 때마다 <code class=\"language-text\">answer</code>값과 현재의 <code class=\"language-text\">res</code>값을 비교하면서 더 큰값을 <code class=\"language-text\">answer</code>에 추가한다.</li>\n</ul>\n<h3 id=\"최대매출-동작방식-\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EB%8C%80%EB%A7%A4%EC%B6%9C-%EB%8F%99%EC%9E%91%EB%B0%A9%EC%8B%9D-\" aria-label=\"최대매출 동작방식  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최대매출 동작방식 🐎</h3>\n<p><img src=\"https://velog.velcdn.com/cloudflare/jooyoung/a33e2846-dcaf-44d5-ac02-9456caec1f96/%E1%84%83%E1%85%A1%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A9%E1%84%83%E1%85%B3.png\" alt=\"\"></p>\n<p><code class=\"language-text\">위에서 말한 해결 방식</code>처럼 처음 시작은 k 길이만큼 -3,3,1을 <code class=\"language-text\">res</code>에 더해준다. 그런다음 다음으로 넘어갈때는 문이 미끄러지는 거와 같이 오른쪽으로 문이 1칸 가게된다. 그때의 <code class=\"language-text\">res</code>값은 -3을 더해주고 뒤에 값 -3을 빼준다. 이런식으로 쭉 진행한다면 반복문이 한번 다 돌면 값이 나오므로 시간 복잡도는 <code class=\"language-text\">O(n)</code>이 된다.</p>\n<br/>\n<p><strong>궁금하신 점이 있다면 아래 <code class=\"language-text\">댓글</code>로 남겨주세요!👇</strong></p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%ED%88%AC-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80\">투 포인터 알고리즘이란?🧐</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%88%AC-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%82%AC%EC%9A%A9%EC%9D%B4%EC%9C%A0-\">투 포인터 알고리즘 사용이유 💡</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%88%AC-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%98%88%EC%A0%9C-\">투 포인터 알고리즘 예제 📝</a></p>\n<ul>\n<li><a href=\"#%EC%9E%85%EB%A0%A5%EC%84%A4%EB%AA%85-%EF%B8%8F\">입력설명 🕵🏻‍♂️</a></li>\n<li><a href=\"#%EC%9E%85%EB%A0%A5%EC%98%88%EC%A0%9C-%EF%B8%8F\">입력예제 ✒️</a></li>\n<li><a href=\"#%ED%95%B4%EA%B2%B0%EB%B0%A9%EC%8B%9D-\">해결방식 🗝</a></li>\n<li><a href=\"#%EB%8F%99%EC%9E%91%EB%B0%A9%EC%8B%9D-\">동작방식 🐎</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%94%A9-%EC%9C%88%EB%8F%84%EC%9A%B0sliding-window%EB%9E%80\">슬라이딩 윈도우(sliding window)란?🤔</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%94%A9-%EC%9C%88%EB%8F%84%EC%9A%B0sliding-window-%EC%98%88%EC%A0%9C-\">슬라이딩 윈도우(sliding window) 예제 📝</a></p>\n<ul>\n<li><a href=\"#%EC%9E%85%EB%A0%A5%EC%84%A4%EB%AA%85-%EF%B8%8F-1\">입력설명 🕵🏻‍♂️</a></li>\n<li><a href=\"#%EC%9E%85%EB%A0%A5%EC%98%88%EC%A0%9C-%EF%B8%8F-1\">입력예제 ✒️</a></li>\n<li><a href=\"#%EC%B5%9C%EB%8C%80%EB%A7%A4%EC%B6%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EC%8B%9D-\">최대매출 해결방식 🗝</a></li>\n<li><a href=\"#%EC%B5%9C%EB%8C%80%EB%A7%A4%EC%B6%9C-%EB%8F%99%EC%9E%91%EB%B0%A9%EC%8B%9D-\">최대매출 동작방식 🐎</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"코딩 테스트 심심치 않게 나오는 과 에 대한 개념과 원리를 파악하고자 포스팅했습니다. 🧑🏻‍💻 투 포인터 알고리즘이란?🧐 이란 이름 그대로 두 가지 포인터를 사용하여 문자열이나 배열에서 원하는 값을 찾는 방식이다. 대표적인 문제로는  문제가 있다. 투 포인터 알고리즘 사용이유 💡 투 포인터 알고리즘 없이 무작정 탐색(반복문)을 사용하면 보통 이중 포문을 사용하면서 문제를 풀게 되는데 시간 복잡도 이 넘어가며 너무 많은 시간이 걸리는 경우가 많다. 투 포인터 알고리즘은 반복문이 한번 돌기 때문에 시간 복잡도으로 더 효율적이다. 말로는 어떠한 방법인지 알기 힘들므로 밑에서 유명한 연습문제를 보며 설명해 보겠습니다.😁 투 포인터 알고리즘 예제 📝 N 개의 수로 이루어진 수열이 주어집니다. 이 수열에서 연속 부분 수열의 합이 특정 숫자 M이 되는 경우가 몇 번 있는지 구하는 프로그램을 작성하세요. 만약 N=8, M=6이고 수열이 다음과 같다면 12131112 합이 6이 되는 연속 부분 수열은 …","frontmatter":{"date":"July 14, 2022","title":"(알고리즘) 투포인터 + 슬라이딩 윈도우","categories":"ALGORITHM","author":"키맨","emoji":"📚"},"fields":{"slug":"/what-twopointer-study/"}},"next":{"id":"7b7beb1a-d701-5e52-8910-e667c5cfe6d0","html":"<blockquote>\n<p>막연하게 해시 알고리즘의 원리를 알지 못하고 코딩 테스트를 준비하면서 부족함을 느껴 여러 자료들을 모아 정리했습니다.🧑🏻‍💻</p>\n</blockquote>\n<h2 id=\"해시hash함수란\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EC%8B%9Chash%ED%95%A8%EC%88%98%EB%9E%80\" aria-label=\"해시hash함수란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해시(Hash)함수란?🧐</h2>\n<p><code class=\"language-text\">해시 함수</code>란 데이터의 효율적 관리를 목적으로 임의의길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수입니다. 이때 매핑 전 원래 데이터의 값을 <code class=\"language-text\">키(key)</code>, 매핑 후 데이터의 값을 <code class=\"language-text\">해시값(hash value)</code>, 매핑하는 과정 자체를 <code class=\"language-text\">해싱(hashing)</code>라고 한다.</p>\n<p><img src=\"https://images.velog.io/images/jooyoung/post/0d43e3b0-23ff-4a46-b052-aa7325d85bf8/image.png\" alt=\"\"></p>\n<h2 id=\"해시hash-테이블이란\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EC%8B%9Chash-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%B4%EB%9E%80\" aria-label=\"해시hash 테이블이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해시(Hash) 테이블이란?🤔</h2>\n<p>해시 함수를 사용하여 키를 해시값으로 매핑하고, 이 해시값을 색인(index)혹은 주소 삼아 데이터의 값(value)을 키와 함께 저장하는 자료구조를 <code class=\"language-text\">해시테이블(hash table)</code>이라고 한다. 이때 저장되는 곳을 <code class=\"language-text\">버킷(bucket)</code> 또는 <code class=\"language-text\">슬롯(slot)</code>이라고 한다.</p>\n<p><img src=\"https://images.velog.io/images/jooyoung/post/8abc9bfd-e267-4dc7-be05-ad26777ee860/EMW1YZP.png\" alt=\"\"></p>\n<h2 id=\"해시hash-테이블-예제\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EC%8B%9Chash-%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%98%88%EC%A0%9C\" aria-label=\"해시hash 테이블 예제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해시(Hash) 테이블 예제💡</h2>\n<p>이해를 돕기 위해 예를 들어 보겠다. 스타벅스의 메뉴를 <code class=\"language-text\">배열</code>에 저장한다고 생각하면</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">menu <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'americano'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">price</span><span class=\"token operator\">:</span> <span class=\"token number\">4000</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'cappuccino'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">price</span><span class=\"token operator\">:</span> <span class=\"token number\">4500</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'vanilla latte'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">price</span><span class=\"token operator\">:</span> <span class=\"token number\">5000</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'espresso'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">price</span><span class=\"token operator\">:</span> <span class=\"token number\">4000</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이런 식으로 나올 것이다. 바닐라라떼가 먹고 싶어 가격을 알고 싶다면 Linear Search(선형검색)을 하여 하나하나 찾아봐야한다. 지금은 4개의 메뉴밖에 없어서 괜찮지만 메뉴가 100개 1000개가 된다면 시간은 점점 더 오래 걸릴 것이다. 시간 복잡도는 <code class=\"language-text\">O(n)</code>이다.</p>\n<p>그렇다면 이 메뉴판을 <code class=\"language-text\">해시테이블(hash table)</code>로 만들어 보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">menu <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">americano</span><span class=\"token operator\">:</span> <span class=\"token number\">4000</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">cappuccino</span><span class=\"token operator\">:</span> <span class=\"token number\">4500</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">vanillaLatte</span><span class=\"token operator\">:</span> <span class=\"token number\">5000</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">espresso</span><span class=\"token operator\">:</span> <span class=\"token number\">4000</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이렇게 해시테이블로 메뉴판을 만들게 되면 <code class=\"language-text\">\"vanillaLatte\"</code>는 Key가 될 것이기에 <code class=\"language-text\">menu.americano</code>를 사용하여 바로 찾을 수 있다.👍🏻 시간복잡도는 <code class=\"language-text\">O(1)</code>이다.</p>\n<h2 id=\"해시hash-충돌-\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EC%8B%9Chash-%EC%B6%A9%EB%8F%8C-\" aria-label=\"해시hash 충돌  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해시(Hash) 충돌 💣</h2>\n<p>해시값에 이미 키가 있지만 해시 함수를 거쳐 또 다른 키값이 들어왓을 때 <code class=\"language-text\">해시(Hash) 충돌</code>이라고 부른다.</p>\n<p><img src=\"https://images.velog.io/images/jooyoung/post/942a8ecc-4192-4a09-80db-2165cbe14e61/7PTT8dT.png\" alt=\"\"></p>\n<h3 id=\"체이닝chaining\" style=\"position:relative;\"><a href=\"#%EC%B2%B4%EC%9D%B4%EB%8B%9Dchaining\" aria-label=\"체이닝chaining permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>체이닝(chaining)</h3>\n<p>해시 충돌을 해결하는 방법 중 하나로 <code class=\"language-text\">위의 그림처럼</code> 한 버킷당 들어갈 수 있는 엔트리의 수에 제한을 두지 않음으로써 모든 자료를 해시테이블에 담는 것이다. 해당 버킷에 데이터가 이미 있다면 체인처럼 노드를 추가하여 다음 노드를 가리키는 방식으로 구현하면 된다.</p>\n<br/>\n<p><strong>궁금하신 점이 있다면 아래 <code class=\"language-text\">댓글</code>로 남겨주세요!👇</strong></p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%ED%95%B4%EC%8B%9Chash%ED%95%A8%EC%88%98%EB%9E%80\">해시(Hash)함수란?🧐</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%95%B4%EC%8B%9Chash-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%B4%EB%9E%80\">해시(Hash) 테이블이란?🤔</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%95%B4%EC%8B%9Chash-%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%98%88%EC%A0%9C\">해시(Hash) 테이블 예제💡</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%95%B4%EC%8B%9Chash-%EC%B6%A9%EB%8F%8C-\">해시(Hash) 충돌 💣</a></p>\n<ul>\n<li><a href=\"#%EC%B2%B4%EC%9D%B4%EB%8B%9Dchaining\">체이닝(chaining)</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"July 11, 2022","title":"(알고리즘) 해시(Hash) 알고리즘","categories":"ALGORITHM","author":"키맨","emoji":"📚"},"fields":{"slug":"/what-hash-study/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://s-jooyoung.github.io","comments":{"utterances":{"repo":"S-jooyoung/S-jooyoung.github.io"}}}}},"pageContext":{"slug":"/what-twopointer-study/","nextSlug":"/what-hash-study/","prevSlug":""}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}